/*
 * GCM Test Vectors
 *   by deadcafe.beef
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>

#include "handler.h"

/*
 * Test Vector from
 * https://tools.ietf.org/html/draft-mcgrew-gcm-test-01
 *
 */
/********************************************************
           key = 4c80cdefbb5d10da906ac73c3613a634
                 (16 octets)
           spi = 00004321
           seq = 8765432100000000
                 (8 octets)
         nonce = 2e443b684956ed7e3b244cfe
     plaintext = 45000048699a000080114db7c0a80102
                 c0a801010a9bf15638d3010000010000
                 00000000045f736970045f7564700373
                 69700963796265726369747902646b00
                 0021000101020201
                 (72 octets)
           aad = 000043218765432100000000
                 (12 octets)
     ctext+tag = fecf537e729d5b07dc30df528dd22b76
                 8d1b98736696a6fd348509fa13ceac34
                 cfa2436f14a3f3cf65925bf1f4a13c5d
                 15b21e1884f5ff6247aeabb786b93bce
                 61bc17d768fd9732459018148f6cbe72
                 2fd04796562dfdb4
                 (88 octets)
********************************************************/
static const uint8_t xxx_1_key[] = {
        0x4c, 0x80, 0xcd, 0xef, 0xbb, 0x5d, 0x10, 0xda,
        0x90, 0x6a, 0xc7, 0x3c, 0x36, 0x13, 0xa6, 0x34,
};
static const uint8_t xxx_1_nonce[] = {
        0x2e, 0x44, 0x3b, 0x68, 0x49, 0x56, 0xed, 0x7e,
        0x3b, 0x24, 0x4c, 0xfe,
};
static const uint8_t xxx_1_aad[] = {
        0x00, 0x00, 0x43, 0x21, 0x87, 0x65, 0x43, 0x21,
        0x00, 0x00, 0x00, 0x00,
};
static const uint8_t xxx_1_plaintext[] = {
        0x45, 0x00, 0x00, 0x48, 0x69, 0x9a, 0x00, 0x00,
        0x80, 0x11, 0x4d, 0xb7, 0xc0, 0xa8, 0x01, 0x02,
        0xc0, 0xa8, 0x01, 0x01, 0x0a, 0x9b, 0xf1, 0x56,
        0x38, 0xd3, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x04, 0x5f, 0x73, 0x69,
        0x70, 0x04, 0x5f, 0x75, 0x64, 0x70, 0x03, 0x73,
        0x69, 0x70, 0x09, 0x63, 0x79, 0x62, 0x65, 0x72,
        0x63, 0x69, 0x74, 0x79, 0x02, 0x64, 0x6b, 0x00,
        0x00, 0x21, 0x00, 0x01, 0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_1_icv[] = {
        0x45, 0x90, 0x18, 0x14, 0x8f, 0x6c, 0xbe, 0x72,
        0x2f, 0xd0, 0x47, 0x96, 0x56, 0x2d, 0xfd, 0xb4,
};
static const uint8_t xxx_1_ciphertext[] = {
        0xfe, 0xcf, 0x53, 0x7e, 0x72, 0x9d, 0x5b, 0x07,
        0xdc, 0x30, 0xdf, 0x52, 0x8d, 0xd2, 0x2b, 0x76,
        0x8d, 0x1b, 0x98, 0x73, 0x66, 0x96, 0xa6, 0xfd,
        0x34, 0x85, 0x09, 0xfa, 0x13, 0xce, 0xac, 0x34,
        0xcf, 0xa2, 0x43, 0x6f, 0x14, 0xa3, 0xf3, 0xcf,
        0x65, 0x92, 0x5b, 0xf1, 0xf4, 0xa1, 0x3c, 0x5d,
        0x15, 0xb2, 0x1e, 0x18, 0x84, 0xf5, 0xff, 0x62,
        0x47, 0xae, 0xab, 0xb7, 0x86, 0xb9, 0x3b, 0xce,
        0x61, 0xbc, 0x17, 0xd7, 0x68, 0xfd, 0x97, 0x32,
};

/********************************************************
           key = feffe9928665731c6d6a8f9467308308
                 (16 octets)
           spi = 0000a5f8
           seq = 0000000a
                 (4 octets)
         nonce = cafebabefacedbaddecaf888
     plaintext = 4500003e698f000080114dccc0a80102
                 c0a801010a980035002a2343b2d00100
                 00010000000000000373697009637962
                 65726369747902646b00000100010001
                 (64 octets)
           aad = 0000a5f80000000a
                 (8 octets)
     ctext+tag = deb22cd9b07c72c16e3a65beeb8df304
                 a5a5897d33ae530f1ba76d5d114d2a5c
                 3de81827c10e9a4f51330d0eec416642
                 cfbb85a5b47e48a4ec3b9ba95d918bd1
                 83b70d3aa8bc6ee4c309e9d85a41ad4a
                 (80 octets)
********************************************************/
static const uint8_t xxx_2_key[] = {
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
        0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
};

static const uint8_t xxx_2_nonce[] = {
        0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
        0xde, 0xca, 0xf8, 0x88,
};

static const uint8_t xxx_2_aad[] = {
        0x00, 0x00, 0xa5, 0xf8, 0x00, 0x00, 0x00, 0x0a,
};

static const uint8_t xxx_2_plaintext[] = {
        0x45, 0x00, 0x00, 0x3e, 0x69, 0x8f, 0x00, 0x00,
        0x80, 0x11, 0x4d, 0xcc, 0xc0, 0xa8, 0x01, 0x02,
        0xc0, 0xa8, 0x01, 0x01, 0x0a, 0x98, 0x00, 0x35,
        0x00, 0x2a, 0x23, 0x43, 0xb2, 0xd0, 0x01, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x73, 0x69, 0x70, 0x09, 0x63, 0x79, 0x62,
        0x65, 0x72, 0x63, 0x69, 0x74, 0x79, 0x02, 0x64,
        0x6b, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
};

static const uint8_t xxx_2_icv[] = {
        0x83, 0xb7, 0x0d, 0x3a, 0xa8, 0xbc, 0x6e, 0xe4,
        0xc3, 0x09, 0xe9, 0xd8, 0x5a, 0x41, 0xad, 0x4a,
};

static const uint8_t xxx_2_ciphertext[] = {
        0xde, 0xb2, 0x2c, 0xd9, 0xb0, 0x7c, 0x72, 0xc1,
        0x6e, 0x3a, 0x65, 0xbe, 0xeb, 0x8d, 0xf3, 0x04,
        0xa5, 0xa5, 0x89, 0x7d, 0x33, 0xae, 0x53, 0x0f,
        0x1b, 0xa7, 0x6d, 0x5d, 0x11, 0x4d, 0x2a, 0x5c,
        0x3d, 0xe8, 0x18, 0x27, 0xc1, 0x0e, 0x9a, 0x4f,
        0x51, 0x33, 0x0d, 0x0e, 0xec, 0x41, 0x66, 0x42,
        0xcf, 0xbb, 0x85, 0xa5, 0xb4, 0x7e, 0x48, 0xa4,
        0xec, 0x3b, 0x9b, 0xa9, 0x5d, 0x91, 0x8b, 0xd1,
};

/********************************************************
           key = abbccddef00112233445566778899aab
                 abbccddef00112233445566778899aab
                 (32 octets)
           spi = 4a2cbfe3
           seq = 00000002
                 (4 octets)
         nonce = 112233440102030405060708
     plaintext = 4500003069a6400080062690c0a80102
                 9389155e0a9e008b2dc57ee000000000
                 7002400020bf0000020405b401010402
                 01020201
                 (52 octets)
           aad = 4a2cbfe300000002
                 (8 octets)
     ctext+tag = ff425c9b724599df7a3bcd510194e00d
                 6a78107f1b0b1cbf06efae9d65a5d763
                 748a637985771d347f0545659f14e99d
                 ef842d8eb335f4eecfdbf831824b4c49
                 15956c96
                 (68 octets)
********************************************************/
static const uint8_t xxx_3_key[] = {
        0xab, 0xbc, 0xcd, 0xde, 0xf0, 0x01, 0x12, 0x23,
        0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab,
        0xab, 0xbc, 0xcd, 0xde, 0xf0, 0x01, 0x12, 0x23,
        0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab,
};
static const uint8_t xxx_3_nonce[] = {
        0x11, 0x22, 0x33, 0x44, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08,
};
static const uint8_t xxx_3_aad[] = {
        0x4a, 0x2c, 0xbf, 0xe3, 0x00, 0x00, 0x00, 0x02,
};
static const uint8_t xxx_3_plaintext[] = {
        0x45, 0x00, 0x00, 0x30, 0x69, 0xa6, 0x40, 0x00,
        0x80, 0x06, 0x26, 0x90, 0xc0, 0xa8, 0x01, 0x02,
        0x93, 0x89, 0x15, 0x5e, 0x0a, 0x9e, 0x00, 0x8b,
        0x2d, 0xc5, 0x7e, 0xe0, 0x00, 0x00, 0x00, 0x00,
        0x70, 0x02, 0x40, 0x00, 0x20, 0xbf, 0x00, 0x00,
        0x02, 0x04, 0x05, 0xb4, 0x01, 0x01, 0x04, 0x02,
        0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_3_icv[] = {
        0xb3, 0x35, 0xf4, 0xee, 0xcf, 0xdb, 0xf8, 0x31,
        0x82, 0x4b, 0x4c, 0x49, 0x15, 0x95, 0x6c, 0x96,
};
static const uint8_t xxx_3_ciphertext[] = {
        0xff, 0x42, 0x5c, 0x9b, 0x72, 0x45, 0x99, 0xdf,
        0x7a, 0x3b, 0xcd, 0x51, 0x01, 0x94, 0xe0, 0x0d,
        0x6a, 0x78, 0x10, 0x7f, 0x1b, 0x0b, 0x1c, 0xbf,
        0x06, 0xef, 0xae, 0x9d, 0x65, 0xa5, 0xd7, 0x63,
        0x74, 0x8a, 0x63, 0x79, 0x85, 0x77, 0x1d, 0x34,
        0x7f, 0x05, 0x45, 0x65, 0x9f, 0x14, 0xe9, 0x9d,
        0xef, 0x84, 0x2d, 0x8e,
};

/********************************************************
           key = 00000000000000000000000000000000
                 (16 octets)
           spi = 00000000
           seq = 00000001
                 (4 octets)
         nonce = 000000000000000000000000
     plaintext = 4500003c99c500008001cb7a40679318
                 010101010800075c0200440061626364
                 65666768696a6b6c6d6e6f7071727374
                 75767761626364656667686901020201
                 (64 octets)
           aad = 0000000000000001
                 (8 octets)
     ctext+tag = 4688daf2f973a392732909c331d56d60
                 f694abaa414b5e7ff5fdcdfff5e9a284
                 456476492719ffb64de7d9dca1e1d894
                 bc3bd57873ed4d181d19d4d5c8c18af3
                 f821d496eeb096e98ad2b69e4799c71d
                 (80 octets)

********************************************************/
static const uint8_t xxx_4_key[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const uint8_t xxx_4_nonce[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
};
static const uint8_t xxx_4_aad[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
};
static const uint8_t xxx_4_plaintext[] = {
        0x45, 0x00, 0x00, 0x3c, 0x99, 0xc5, 0x00, 0x00,
        0x80, 0x01, 0xcb, 0x7a, 0x40, 0x67, 0x93, 0x18,
        0x01, 0x01, 0x01, 0x01, 0x08, 0x00, 0x07, 0x5c,
        0x02, 0x00, 0x44, 0x00, 0x61, 0x62, 0x63, 0x64,
        0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
        0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74,
        0x75, 0x76, 0x77, 0x61, 0x62, 0x63, 0x64, 0x65,
        0x66, 0x67, 0x68, 0x69, 0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_4_icv[] = {
        0xf8, 0x21, 0xd4, 0x96, 0xee, 0xb0, 0x96, 0xe9,
        0x8a, 0xd2, 0xb6, 0x9e, 0x47, 0x99, 0xc7, 0x1d,
};
static const uint8_t xxx_4_ciphertext[] = {
        0x46, 0x88, 0xda, 0xf2, 0xf9, 0x73, 0xa3, 0x92,
        0x73, 0x29, 0x09, 0xc3, 0x31, 0xd5, 0x6d, 0x60,
        0xf6, 0x94, 0xab, 0xaa, 0x41, 0x4b, 0x5e, 0x7f,
        0xf5, 0xfd, 0xcd, 0xff, 0xf5, 0xe9, 0xa2, 0x84,
        0x45, 0x64, 0x76, 0x49, 0x27, 0x19, 0xff, 0xb6,
        0x4d, 0xe7, 0xd9, 0xdc, 0xa1, 0xe1, 0xd8, 0x94,
        0xbc, 0x3b, 0xd5, 0x78, 0x73, 0xed, 0x4d, 0x18,
        0x1d, 0x19, 0xd4, 0xd5, 0xc8, 0xc1, 0x8a, 0xf3,
};

/********************************************************
           key = 3de09874b388e6491988d0c3607eae1f
                 (16 octets)
           spi = 42f67e3f
           seq = 1010101010101010
                 (8 octets)
         nonce = 57690e434e280000a2fca1a3
     plaintext = 4500003c99c300008001cb7c40679318
                 010101010800085c0200430061626364
                 65666768696a6b6c6d6e6f7071727374
                 75767761626364656667686901020201
                 (64 octets)
           aad = 42f67e3f1010101010101010
                 (12 octets)
     ctext+tag = fba2caa4853cf9f0f22cb10d86dd83b0
                 fec75691cf1a04b00d1138ec9c357917
                 65acbd8701ad79845bf9fe3fba487bc9
                 1755e6662b4c8d0d1f5e22739530320a
                 e0d731cc978ecafaeae88f00e80d6e48
                 (80 octets)
********************************************************/
static const uint8_t xxx_5_key[] = {
        0x3d, 0xe0, 0x98, 0x74, 0xb3, 0x88, 0xe6, 0x49,
        0x19, 0x88, 0xd0, 0xc3, 0x60, 0x7e, 0xae, 0x1f,
};
static const uint8_t xxx_5_nonce[] = {
        0x57, 0x69, 0x0e, 0x43, 0x4e, 0x28, 0x00, 0x00,
        0xa2, 0xfc, 0xa1, 0xa3,
};
static const uint8_t xxx_5_aad[] = {
        0x42, 0xf6, 0x7e, 0x3f, 0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
};
static const uint8_t xxx_5_plaintext[] = {
        0x45, 0x00, 0x00, 0x3c, 0x99, 0xc3, 0x00, 0x00,
        0x80, 0x01, 0xcb, 0x7c, 0x40, 0x67, 0x93, 0x18,
        0x01, 0x01, 0x01, 0x01, 0x08, 0x00, 0x08, 0x5c,
        0x02, 0x00, 0x43, 0x00, 0x61, 0x62, 0x63, 0x64,
        0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
        0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74,
        0x75, 0x76, 0x77, 0x61, 0x62, 0x63, 0x64, 0x65,
        0x66, 0x67, 0x68, 0x69, 0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_5_icv[] = {
        0xe0, 0xd7, 0x31, 0xcc, 0x97, 0x8e, 0xca, 0xfa,
        0xea, 0xe8, 0x8f, 0x00, 0xe8, 0x0d, 0x6e, 0x48,
};
static const uint8_t xxx_5_ciphertext[] = {
        0xfb, 0xa2, 0xca, 0xa4, 0x85, 0x3c, 0xf9, 0xf0,
        0xf2, 0x2c, 0xb1, 0x0d, 0x86, 0xdd, 0x83, 0xb0,
        0xfe, 0xc7, 0x56, 0x91, 0xcf, 0x1a, 0x04, 0xb0,
        0x0d, 0x11, 0x38, 0xec, 0x9c, 0x35, 0x79, 0x17,
        0x65, 0xac, 0xbd, 0x87, 0x01, 0xad, 0x79, 0x84,
        0x5b, 0xf9, 0xfe, 0x3f, 0xba, 0x48, 0x7b, 0xc9,
        0x17, 0x55, 0xe6, 0x66, 0x2b, 0x4c, 0x8d, 0x0d,
        0x1f, 0x5e, 0x22, 0x73, 0x95, 0x30, 0x32, 0x0a,
};

/********************************************************
           key = 3de09874b388e6491988d0c3607eae1f
                 (16 octets)
           spi = 42f67e3f
           seq = 1010101010101010
                 (8 octets)
         nonce = 57690e434e280000a2fca1a3
     plaintext = 4500001c42a200008001441f406793b6
                 e00000020a00f5ff01020201
                 (28 octets)
           aad = 42f67e3f1010101010101010
                 (12 octets)
     ctext+tag = fba2ca845e5df9f0f22c3e6e86dd831e
                 1fc65792cd1af9130e1379ed369f071f
                 35e034be95f112e4e7d05d35
                 (44 octets)
********************************************************/
static const uint8_t xxx_6_key[] = {
        0x3d, 0xe0, 0x98, 0x74, 0xb3, 0x88, 0xe6, 0x49,
        0x19, 0x88, 0xd0, 0xc3, 0x60, 0x7e, 0xae, 0x1f,
};
static const uint8_t xxx_6_nonce[] = {
        0x57, 0x69, 0x0e, 0x43, 0x4e, 0x28, 0x00, 0x00,
        0xa2, 0xfc, 0xa1, 0xa3,
};
static const uint8_t xxx_6_aad[] = {
        0x42, 0xf6, 0x7e, 0x3f, 0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
};
static const uint8_t xxx_6_plaintext[] = {
        0x45, 0x00, 0x00, 0x1c, 0x42, 0xa2, 0x00, 0x00,
        0x80, 0x01, 0x44, 0x1f, 0x40, 0x67, 0x93, 0xb6,
        0xe0, 0x00, 0x00, 0x02, 0x0a, 0x00, 0xf5, 0xff,
        0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_6_icv[] = {
        0x36, 0x9f, 0x07, 0x1f, 0x35, 0xe0, 0x34, 0xbe,
        0x95, 0xf1, 0x12, 0xe4, 0xe7, 0xd0, 0x5d, 0x35,
};
static const uint8_t xxx_6_ciphertext[] = {
        0xfb, 0xa2, 0xca, 0x84, 0x5e, 0x5d, 0xf9, 0xf0,
        0xf2, 0x2c, 0x3e, 0x6e, 0x86, 0xdd, 0x83, 0x1e,
        0x1f, 0xc6, 0x57, 0x92, 0xcd, 0x1a, 0xf9, 0x13,
        0x0e, 0x13, 0x79, 0xed,
};

/********************************************************
           key = feffe9928665731c6d6a8f9467308308
                 feffe9928665731c
                 (24 octets)
           spi = 0000a5f8
           seq = 0000000a
                 (4 octets)
         nonce = cafebabefacedbaddecaf888
     plaintext = 45000028a4ad4000400678800a01038f
                 0a010612802306b8cb712602dd6bb03e
                 501016d075680001
                 (40 octets)
           aad = 0000a5f80000000a
                 (8 octets)
     ctext+tag = a5b1f8066029aea40e598b8122de0242
                 0938b3ab33f828e687b8858b5bfbdbd0
                 315b27452144cc7795457b9652037f53
                 18027b5b4cd7a636
                 (56 octets)
********************************************************/
static const uint8_t xxx_7_key[] = {
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
        0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
};
static const uint8_t xxx_7_nonce[] = {
        0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
        0xde, 0xca, 0xf8, 0x88,
};
static const uint8_t xxx_7_aad[] = {
        0x00, 0x00, 0xa5, 0xf8, 0x00, 0x00, 0x00, 0x0a,
};
static const uint8_t xxx_7_plaintext[] = {
        0x45, 0x00, 0x00, 0x28, 0xa4, 0xad, 0x40, 0x00,
        0x40, 0x06, 0x78, 0x80, 0x0a, 0x01, 0x03, 0x8f,
        0x0a, 0x01, 0x06, 0x12, 0x80, 0x23, 0x06, 0xb8,
        0xcb, 0x71, 0x26, 0x02, 0xdd, 0x6b, 0xb0, 0x3e,
        0x50, 0x10, 0x16, 0xd0, 0x75, 0x68, 0x00, 0x01,
};
static const uint8_t xxx_7_icv[] = {
        0x95, 0x45, 0x7b, 0x96, 0x52, 0x03, 0x7f, 0x53,
        0x18, 0x02, 0x7b, 0x5b, 0x4c, 0xd7, 0xa6, 0x36,
};
static const uint8_t xxx_7_ciphertext[] = {
        0xa5, 0xb1, 0xf8, 0x06, 0x60, 0x29, 0xae, 0xa4,
        0x0e, 0x59, 0x8b, 0x81, 0x22, 0xde, 0x02, 0x42,
        0x09, 0x38, 0xb3, 0xab, 0x33, 0xf8, 0x28, 0xe6,
        0x87, 0xb8, 0x85, 0x8b, 0x5b, 0xfb, 0xdb, 0xd0,
        0x31, 0x5b, 0x27, 0x45, 0x21, 0x44, 0xcc, 0x77,
};

/********************************************************
           key = abbccddef00112233445566778899aab
                 (16 octets)
           spi = 00000100
           seq = 0000000000000001
                 (8 octets)
         nonce = decaf888cafedebaceface74
     plaintext = 4500004933ba00007f119106c3fb1d10
                 c2b1d326c02831ce0035dd7b800302d5
                 00004e20001e8c18d75b81dc91baa047
                 6b91b924b280389d92c963bac046ec95
                 9b6266c04722b14923010101
                 (76 octets)
           aad = 000001000000000000000001
                 (12 octets)
     ctext+tag = 18a6fd42f72cbf4ab2a2ea901f73d814
                 e3e7f243d95412e1c349c1d2fbec168f
                 9190feebaf2cb01984e65863965d7472
                 b79da345e0e780191f0d2f0e0f496c22
                 6f2127b27db35724e7845d68651f57e6
                 5f354f75ff17015769623436

********************************************************/
static const uint8_t xxx_8_key[] = {
        0xab, 0xbc, 0xcd, 0xde, 0xf0, 0x01, 0x12, 0x23,
        0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab,
};
static const uint8_t xxx_8_nonce[] = {
        0xde, 0xca, 0xf8, 0x88, 0xca, 0xfe, 0xde, 0xba,
        0xce, 0xfa, 0xce, 0x74,
};
static const uint8_t xxx_8_aad[] = {
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01,
};
static const uint8_t xxx_8_plaintext[] = {
        0x45, 0x00, 0x00, 0x49, 0x33, 0xba, 0x00, 0x00,
        0x7f, 0x11, 0x91, 0x06, 0xc3, 0xfb, 0x1d, 0x10,
        0xc2, 0xb1, 0xd3, 0x26, 0xc0, 0x28, 0x31, 0xce,
        0x00, 0x35, 0xdd, 0x7b, 0x80, 0x03, 0x02, 0xd5,
        0x00, 0x00, 0x4e, 0x20, 0x00, 0x1e, 0x8c, 0x18,
        0xd7, 0x5b, 0x81, 0xdc, 0x91, 0xba, 0xa0, 0x47,
        0x6b, 0x91, 0xb9, 0x24, 0xb2, 0x80, 0x38, 0x9d,
        0x92, 0xc9, 0x63, 0xba, 0xc0, 0x46, 0xec, 0x95,
        0x9b, 0x62, 0x66, 0xc0, 0x47, 0x22, 0xb1, 0x49,
        0x23, 0x01, 0x01, 0x01,
};
static const uint8_t xxx_8_icv[] = {
        0x65, 0x1f, 0x57, 0xe6, 0x5f, 0x35, 0x4f, 0x75,
        0xff, 0x17, 0x01, 0x57, 0x69, 0x62, 0x34, 0x36,
};
static const uint8_t xxx_8_ciphertext[] = {
        0x18, 0xa6, 0xfd, 0x42, 0xf7, 0x2c, 0xbf, 0x4a,
        0xb2, 0xa2, 0xea, 0x90, 0x1f, 0x73, 0xd8, 0x14,
        0xe3, 0xe7, 0xf2, 0x43, 0xd9, 0x54, 0x12, 0xe1,
        0xc3, 0x49, 0xc1, 0xd2, 0xfb, 0xec, 0x16, 0x8f,
        0x91, 0x90, 0xfe, 0xeb, 0xaf, 0x2c, 0xb0, 0x19,
        0x84, 0xe6, 0x58, 0x63, 0x96, 0x5d, 0x74, 0x72,
        0xb7, 0x9d, 0xa3, 0x45, 0xe0, 0xe7, 0x80, 0x19,
        0x1f, 0x0d, 0x2f, 0x0e, 0x0f, 0x49, 0x6c, 0x22,
        0x6f, 0x21, 0x27, 0xb2, 0x7d, 0xb3, 0x57, 0x24,
        0xe7, 0x84, 0x5d, 0x68,
};

/********************************************************
           key = abbccddef00112233445566778899aab
                 abbccddef00112233445566778899aab
                 (32 octets)
           spi = 17405e67
           seq = 156f3126dd0db99b
                 (8 octets)
         nonce = 73616c74616e640169766563
     plaintext = 45080028732c00004006e9f90a010612
                 0a01038f06b88023dd6bafbecb712602
                 50101f646d540001
                 (40 octets)
           aad = 17405e67156f3126dd0db99b
                 (12 octets)
     ctext+tag = f2d69ecdbd5a0d5b8d5ef38bad4da58d
                 1f278fde98ef67549d524a3018d9a57f
                 f4d3a31ce673119e451626c2415771e3
                 b7eebca614c89b35
                 (56 octets)

********************************************************/
static const uint8_t xxx_9_key[] = {
        0xab, 0xbc, 0xcd, 0xde, 0xf0, 0x01, 0x12, 0x23,
        0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab,
        0xab, 0xbc, 0xcd, 0xde, 0xf0, 0x01, 0x12, 0x23,
        0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab,
};
static const uint8_t xxx_9_nonce[] = {
        0x73, 0x61, 0x6c, 0x74, 0x61, 0x6e, 0x64, 0x01,
        0x69, 0x76, 0x65, 0x63,
};
static const uint8_t xxx_9_aad[] = {
        0x17, 0x40, 0x5e, 0x67, 0x15, 0x6f, 0x31, 0x26,
        0xdd, 0x0d, 0xb9, 0x9b,
};
static const uint8_t xxx_9_plaintext[] = {
        0x45, 0x08, 0x00, 0x28, 0x73, 0x2c, 0x00, 0x00,
        0x40, 0x06, 0xe9, 0xf9, 0x0a, 0x01, 0x06, 0x12,
        0x0a, 0x01, 0x03, 0x8f, 0x06, 0xb8, 0x80, 0x23,
        0xdd, 0x6b, 0xaf, 0xbe, 0xcb, 0x71, 0x26, 0x02,
        0x50, 0x10, 0x1f, 0x64, 0x6d, 0x54, 0x00, 0x01,
};
static const uint8_t xxx_9_icv[] = {
        0x45, 0x16, 0x26, 0xc2, 0x41, 0x57, 0x71, 0xe3,
        0xb7, 0xee, 0xbc, 0xa6, 0x14, 0xc8, 0x9b, 0x35,
};
static const uint8_t xxx_9_ciphertext[] = {
        0xf2, 0xd6, 0x9e, 0xcd, 0xbd, 0x5a, 0x0d, 0x5b,
        0x8d, 0x5e, 0xf3, 0x8b, 0xad, 0x4d, 0xa5, 0x8d,
        0x1f, 0x27, 0x8f, 0xde, 0x98, 0xef, 0x67, 0x54,
        0x9d, 0x52, 0x4a, 0x30, 0x18, 0xd9, 0xa5, 0x7f,
        0xf4, 0xd3, 0xa3, 0x1c, 0xe6, 0x73, 0x11, 0x9e,
};

/********************************************************
           key = 3de09874b388e6491988d0c3607eae1f
                 (16 octets)
           spi = 42f67e3f
           seq = 1010101010101010
                 (8 octets)
         nonce = 57690e434e280000a2fca1a3
     plaintext = 45000049333e00007f119182c3fb1d10
                 c2b1d326c02831ce0035cb458003025b
                 000001e0001e8c18d65759d52284a035
                 2c71475c8880391c764d6e5ee0496b32
                 5ae270c03899493915010101
                 (76 octets)
           aad = 42f67e3f1010101010101010
                 (12 octets)
     ctext+tag = fba2cad12fc1f9f00d3cebf305410db8
                 3d7784b607323d220f24b0a97d541828
                 00cadb0f68d99ef0e0c0c89ae9bea888
                 4e52d65bc1afd0740f742444747b5b39
                 ab533163aad4550ee5160975cdb608c5
                 769189609763b8e18caa81e2
                 (92 octets)
********************************************************/
static const uint8_t xxx_10_key[] = {
        0x3d, 0xe0, 0x98, 0x74, 0xb3, 0x88, 0xe6, 0x49,
        0x19, 0x88, 0xd0, 0xc3, 0x60, 0x7e, 0xae, 0x1f,
};
static const uint8_t xxx_10_nonce[] = {
        0x57, 0x69, 0x0e, 0x43, 0x4e, 0x28, 0x00, 0x00,
        0xa2, 0xfc, 0xa1, 0xa3,
};
static const uint8_t xxx_10_aad[] = {
        0x42, 0xf6, 0x7e, 0x3f, 0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
};
static const uint8_t xxx_10_plaintext[] = {
        0x45, 0x00, 0x00, 0x49, 0x33, 0x3e, 0x00, 0x00,
        0x7f, 0x11, 0x91, 0x82, 0xc3, 0xfb, 0x1d, 0x10,
        0xc2, 0xb1, 0xd3, 0x26, 0xc0, 0x28, 0x31, 0xce,
        0x00, 0x35, 0xcb, 0x45, 0x80, 0x03, 0x02, 0x5b,
        0x00, 0x00, 0x01, 0xe0, 0x00, 0x1e, 0x8c, 0x18,
        0xd6, 0x57, 0x59, 0xd5, 0x22, 0x84, 0xa0, 0x35,
        0x2c, 0x71, 0x47, 0x5c, 0x88, 0x80, 0x39, 0x1c,
        0x76, 0x4d, 0x6e, 0x5e, 0xe0, 0x49, 0x6b, 0x32,
        0x5a, 0xe2, 0x70, 0xc0, 0x38, 0x99, 0x49, 0x39,
        0x15, 0x01, 0x01, 0x01,
};
static const uint8_t xxx_10_icv[] = {
        0xcd, 0xb6, 0x08, 0xc5, 0x76, 0x91, 0x89, 0x60,
        0x97, 0x63, 0xb8, 0xe1, 0x8c, 0xaa, 0x81, 0xe2,
};
static const uint8_t xxx_10_ciphertext[] = {
        0xfb, 0xa2, 0xca, 0xd1, 0x2f, 0xc1, 0xf9, 0xf0,
        0x0d, 0x3c, 0xeb, 0xf3, 0x05, 0x41, 0x0d, 0xb8,
        0x3d, 0x77, 0x84, 0xb6, 0x07, 0x32, 0x3d, 0x22,
        0x0f, 0x24, 0xb0, 0xa9, 0x7d, 0x54, 0x18, 0x28,
        0x00, 0xca, 0xdb, 0x0f, 0x68, 0xd9, 0x9e, 0xf0,
        0xe0, 0xc0, 0xc8, 0x9a, 0xe9, 0xbe, 0xa8, 0x88,
        0x4e, 0x52, 0xd6, 0x5b, 0xc1, 0xaf, 0xd0, 0x74,
        0x0f, 0x74, 0x24, 0x44, 0x74, 0x7b, 0x5b, 0x39,
        0xab, 0x53, 0x31, 0x63, 0xaa, 0xd4, 0x55, 0x0e,
        0xe5, 0x16, 0x09, 0x75,
};

/********************************************************
           key = abbccddef00112233445566778899aab
                 abbccddef00112233445566778899aab
                 (32 octets)
           spi = 17405e67
           seq = 156f3126dd0db99b
                 (8 octets)
         nonce = 73616c74616e640169766563
     plaintext = 636973636f0172756c65730174686501
                 6e6574776501646566696e6501746865
                 746563686e6f6c6f6769657301746861
                 7477696c6c01646566696e65746f6d6f
                 72726f7701020201
                 (72 octets)
           aad = 17405e67156f3126dd0db99b
                 (12 octets)
     ctext+tag = d4b7ed86a1777f2ea13d6973d324c69e
                 7b43f826fb56831226508bebd2dceb18
                 d0a6df10e5487df074113e14c641024e
                 3e6773d91a62ee429b043a10e3efe6b0
                 12a49363412364f8c0cac587f249e56b
                 11e24f30e44ccc76
                 (88 octets)
********************************************************/
static const uint8_t xxx_11_key[] = {
        0xab, 0xbc, 0xcd, 0xde, 0xf0, 0x01, 0x12, 0x23,
        0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab,
        0xab, 0xbc, 0xcd, 0xde, 0xf0, 0x01, 0x12, 0x23,
        0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab,
};
static const uint8_t xxx_11_nonce[] = {
        0x73, 0x61, 0x6c, 0x74, 0x61, 0x6e, 0x64, 0x01,
        0x69, 0x76, 0x65, 0x63,
};
static const uint8_t xxx_11_aad[] = {
        0x17, 0x40, 0x5e, 0x67, 0x15, 0x6f, 0x31, 0x26,
        0xdd, 0x0d, 0xb9, 0x9b,
};
static const uint8_t xxx_11_plaintext[] = {
        0x63, 0x69, 0x73, 0x63, 0x6f, 0x01, 0x72, 0x75,
        0x6c, 0x65, 0x73, 0x01, 0x74, 0x68, 0x65, 0x01,
        0x6e, 0x65, 0x74, 0x77, 0x65, 0x01, 0x64, 0x65,
        0x66, 0x69, 0x6e, 0x65, 0x01, 0x74, 0x68, 0x65,
        0x74, 0x65, 0x63, 0x68, 0x6e, 0x6f, 0x6c, 0x6f,
        0x67, 0x69, 0x65, 0x73, 0x01, 0x74, 0x68, 0x61,
        0x74, 0x77, 0x69, 0x6c, 0x6c, 0x01, 0x64, 0x65,
        0x66, 0x69, 0x6e, 0x65, 0x74, 0x6f, 0x6d, 0x6f,
        0x72, 0x72, 0x6f, 0x77, 0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_11_icv[] = {
        0xc0, 0xca, 0xc5, 0x87, 0xf2, 0x49, 0xe5, 0x6b,
        0x11, 0xe2, 0x4f, 0x30, 0xe4, 0x4c, 0xcc, 0x76,
};
static const uint8_t xxx_11_ciphertext[] = {
        0xd4, 0xb7, 0xed, 0x86, 0xa1, 0x77, 0x7f, 0x2e,
        0xa1, 0x3d, 0x69, 0x73, 0xd3, 0x24, 0xc6, 0x9e,
        0x7b, 0x43, 0xf8, 0x26, 0xfb, 0x56, 0x83, 0x12,
        0x26, 0x50, 0x8b, 0xeb, 0xd2, 0xdc, 0xeb, 0x18,
        0xd0, 0xa6, 0xdf, 0x10, 0xe5, 0x48, 0x7d, 0xf0,
        0x74, 0x11, 0x3e, 0x14, 0xc6, 0x41, 0x02, 0x4e,
        0x3e, 0x67, 0x73, 0xd9, 0x1a, 0x62, 0xee, 0x42,
        0x9b, 0x04, 0x3a, 0x10, 0xe3, 0xef, 0xe6, 0xb0,
        0x12, 0xa4, 0x93, 0x63, 0x41, 0x23, 0x64, 0xf8,
};

/********************************************************
           key = 7d773d00c144c525ac619d18c84a3f47
                 (16 octets)
           spi = 335467ae
           seq = ffffffff
                 (4 octets)
         nonce = d966426743457e9182443bc6
     plaintext = 01020201
                 (4 octets)
           aad = 335467aeffffffff
                 (8 octets)
     ctext+tag = 437f866bcb3f699fe9b0822bac961c45
                 04bef270
                 (20 octets)
********************************************************/
static const uint8_t xxx_12_key[] = {
        0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25,
        0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47,
};
static const uint8_t xxx_12_nonce[] = {
        0xd9, 0x66, 0x42, 0x67, 0x43, 0x45, 0x7e, 0x91,
        0x82, 0x44, 0x3b, 0xc6,
};
static const uint8_t xxx_12_aad[] = {
        0x33, 0x54, 0x67, 0xae, 0xff, 0xff, 0xff, 0xff,
};
static const uint8_t xxx_12_plaintext[] = {
        0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_12_icv[] = {
        0xcb, 0x3f, 0x69, 0x9f, 0xe9, 0xb0, 0x82, 0x2b,
        0xac, 0x96, 0x1c, 0x45, 0x04, 0xbe, 0xf2, 0x70,
};
static const uint8_t xxx_12_ciphertext[] = {
        0x43, 0x7f, 0x86, 0x6b,
};

/********************************************************
           key = abbccddef00112233445566778899aab
                 (16 octets)
           spi = 00000100
           seq = 0000000000000001
                 (8 octets)
         nonce = decaf888cafedebaceface74
     plaintext = 746f016265016f72016e6f7401746f01
                 62650001
                 (20 octets)
           aad = 000001000000000000000001
                 (12 octets)
     ctext+tag = 29c9fc69a197d038ccdd14e2ddfcaa05
                 43332164412503524303ed3c6c5f2838
                 43af8c3e
                 (36 octets)
********************************************************/
static const uint8_t xxx_13_key[] = {
        0xab, 0xbc, 0xcd, 0xde, 0xf0, 0x01, 0x12, 0x23,
        0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab,
};
static const uint8_t xxx_13_nonce[] = {
        0xde, 0xca, 0xf8, 0x88, 0xca, 0xfe, 0xde, 0xba,
        0xce, 0xfa, 0xce, 0x74,
};
static const uint8_t xxx_13_aad[] = {
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01,
};
static const uint8_t xxx_13_plaintext[] = {
        0x74, 0x6f, 0x01, 0x62, 0x65, 0x01, 0x6f, 0x72,
        0x01, 0x6e, 0x6f, 0x74, 0x01, 0x74, 0x6f, 0x01,
        0x62, 0x65, 0x00, 0x01,
};
static const uint8_t xxx_13_icv[] = {
        0x41, 0x25, 0x03, 0x52, 0x43, 0x03, 0xed, 0x3c,
        0x6c, 0x5f, 0x28, 0x38, 0x43, 0xaf, 0x8c, 0x3e,
};
static const uint8_t xxx_13_ciphertext[] = {
        0x29, 0xc9, 0xfc, 0x69, 0xa1, 0x97, 0xd0, 0x38,
        0xcc, 0xdd, 0x14, 0xe2, 0xdd, 0xfc, 0xaa, 0x05,
        0x43, 0x33, 0x21, 0x64,
};

/********************************************************
           key = 6c6567616c697a656d6172696a75616e
                 61616e64646f69746265666f72656961
                 (32 octets)
           spi = 796b6963
           seq = ffffffffffffffff
                 (8 octets)
         nonce = 7475726e333021696765746d
     plaintext = 45000030da3a00008001df3bc0a80005
                 c0a800010800c6cd0200070061626364
                 65666768696a6b6c6d6e6f7071727374
                 01020201
                 (52 octets)
           aad = 796b6963ffffffffffffffff
                 (12 octets)
     ctext+tag = f97ab2aa356d8edce17644ac8c78e25d
                 d24dedbb29ebf1b64a274b39b49c3a86
                 4cd3d78ca4ae68a32b42458fb57dbe82
                 1dcc63b9d0937ba2945f669368661a32
                 9fb4c053
                 (68 octets)
********************************************************/
static const uint8_t xxx_14_key[] = {
        0x6c, 0x65, 0x67, 0x61, 0x6c, 0x69, 0x7a, 0x65,
        0x6d, 0x61, 0x72, 0x69, 0x6a, 0x75, 0x61, 0x6e,
        0x61, 0x61, 0x6e, 0x64, 0x64, 0x6f, 0x69, 0x74,
        0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x69, 0x61,
};
static const uint8_t xxx_14_nonce[] = {
        0x74, 0x75, 0x72, 0x6e, 0x33, 0x30, 0x21, 0x69,
        0x67, 0x65, 0x74, 0x6d,
};
static const uint8_t xxx_14_aad[] = {
        0x79, 0x6b, 0x69, 0x63, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
};
static const uint8_t xxx_14_plaintext[] = {
        0x45, 0x00, 0x00, 0x30, 0xda, 0x3a, 0x00, 0x00,
        0x80, 0x01, 0xdf, 0x3b, 0xc0, 0xa8, 0x00, 0x05,
        0xc0, 0xa8, 0x00, 0x01, 0x08, 0x00, 0xc6, 0xcd,
        0x02, 0x00, 0x07, 0x00, 0x61, 0x62, 0x63, 0x64,
        0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
        0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74,
        0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_14_icv[] = {
        0xd0, 0x93, 0x7b, 0xa2, 0x94, 0x5f, 0x66, 0x93,
        0x68, 0x66, 0x1a, 0x32, 0x9f, 0xb4, 0xc0, 0x53,
};
static const uint8_t xxx_14_ciphertext[] = {
        0xf9, 0x7a, 0xb2, 0xaa, 0x35, 0x6d, 0x8e, 0xdc,
        0xe1, 0x76, 0x44, 0xac, 0x8c, 0x78, 0xe2, 0x5d,
        0xd2, 0x4d, 0xed, 0xbb, 0x29, 0xeb, 0xf1, 0xb6,
        0x4a, 0x27, 0x4b, 0x39, 0xb4, 0x9c, 0x3a, 0x86,
        0x4c, 0xd3, 0xd7, 0x8c, 0xa4, 0xae, 0x68, 0xa3,
        0x2b, 0x42, 0x45, 0x8f, 0xb5, 0x7d, 0xbe, 0x82,
        0x1d, 0xcc, 0x63, 0xb9,
};

/********************************************************
     algorithm = AES-GMAC-ESP
           key = 4c80cdefbb5d10da906ac73c3613a634
                 (16 octets)
           spi = 00004321
           seq = 00000007
                 (4 octets)
         nonce = 22433c640000000000000000
     plaintext = (0 octets)
           aad = 00004321000000070000000000000000
                 45000030da3a00008001df3bc0a80005
                 c0a800010800c6cd0200070061626364
                 65666768696a6b6c6d6e6f7071727374
                 01020201
                 (68 octets)
     ctext+tag = (16 octets)
        packet = 00004321000000070000000000000000
                 45000030da3a00008001df3bc0a80005
                 c0a800010800c6cd0200070061626364
                 65666768696a6b6c6d6e6f7071727374
                 01020201f2a9a836e155106aa8dcd618
                 e4099aaa
                 (84 octets)
********************************************************/
static const uint8_t xxx_15_key[] = {
        0x4c, 0x80, 0xcd, 0xef, 0xbb, 0x5d, 0x10, 0xda,
        0x90, 0x6a, 0xc7, 0x3c, 0x36, 0x13, 0xa6, 0x34,
};
static const uint8_t xxx_15_nonce[] = {
        0x22, 0x43, 0x3c, 0x64, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
};
static const uint8_t xxx_15_aad[] = {
        0x00, 0x00, 0x43, 0x21, 0x00, 0x00, 0x00, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x45, 0x00, 0x00, 0x30, 0xda, 0x3a, 0x00, 0x00,
        0x80, 0x01, 0xdf, 0x3b, 0xc0, 0xa8, 0x00, 0x05,
        0xc0, 0xa8, 0x00, 0x01, 0x08, 0x00, 0xc6, 0xcd,
        0x02, 0x00, 0x07, 0x00, 0x61, 0x62, 0x63, 0x64,
        0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
        0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74,
        0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_15_plaintext[] = {
};
static const uint8_t xxx_15_icv[] = {
        0xf2, 0xa9, 0xa8, 0x36, 0xe1, 0x55, 0x10, 0x6a,
        0xa8, 0xdc, 0xd6, 0x18, 0xe4, 0x09, 0x9a, 0xaa,
};
static const uint8_t xxx_15_ciphertext[] = {
};

/********************************************************
     algorithm = AES-GCM-ESP
           key = 3de09874b388e6491988d0c3607eae1f
                 (16 octets)
           spi = 3f7ef642
           seq = 1010101010101010
                 (8 octets)
         nonce = 57690e434e280000a2fca1a3
     plaintext = 45000030da3a00008001df3bc0a80005
                 c0a800010800c6cd0200070061626364
                 65666768696a6b6c6d6e6f7071727374
                 01020201
                 (52 octets)
           aad = 3f7ef6421010101010101010
                 (12 octets)
     ctext+tag = fba2caa8c6c5f9f0f22ca54a061210ad
                 3f6e5791cf1aca210d117cec9c357917
                 65acbd8701ad79845bf9fe3fba487bc9
                 6321930684eecadb56912546e7a95c97
                 40d7cb05
                 (68 octets)
        packet = 3f7ef642101010104e280000a2fca1a3
                 fba2caa8c6c5f9f0f22ca54a061210ad
                 3f6e5791cf1aca210d117cec9c357917
                 65acbd8701ad79845bf9fe3fba487bc9
                 6321930684eecadb56912546e7a95c97
                 40d7cb05
                 (84 octets)
********************************************************/
static const uint8_t xxx_16_key[] = {
        0x3d, 0xe0, 0x98, 0x74, 0xb3, 0x88, 0xe6, 0x49,
        0x19, 0x88, 0xd0, 0xc3, 0x60, 0x7e, 0xae, 0x1f,
};
static const uint8_t xxx_16_nonce[] = {
        0x57, 0x69, 0x0e, 0x43, 0x4e, 0x28, 0x00, 0x00,
        0xa2, 0xfc, 0xa1, 0xa3,
};
static const uint8_t xxx_16_aad[] = {
        0x3f, 0x7e, 0xf6, 0x42, 0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
};
static const uint8_t xxx_16_plaintext[] = {
        0x45, 0x00, 0x00, 0x30, 0xda, 0x3a, 0x00, 0x00,
        0x80, 0x01, 0xdf, 0x3b, 0xc0, 0xa8, 0x00, 0x05,
        0xc0, 0xa8, 0x00, 0x01, 0x08, 0x00, 0xc6, 0xcd,
        0x02, 0x00, 0x07, 0x00, 0x61, 0x62, 0x63, 0x64,
        0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
        0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74,
        0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_16_icv[] = {
        0x84, 0xee, 0xca, 0xdb, 0x56, 0x91, 0x25, 0x46,
        0xe7, 0xa9, 0x5c, 0x97, 0x40, 0xd7, 0xcb, 0x05,
};
static const uint8_t xxx_16_ciphertext[] = {
        0xfb, 0xa2, 0xca, 0xa8, 0xc6, 0xc5, 0xf9, 0xf0,
        0xf2, 0x2c, 0xa5, 0x4a, 0x06, 0x12, 0x10, 0xad,
        0x3f, 0x6e, 0x57, 0x91, 0xcf, 0x1a, 0xca, 0x21,
        0x0d, 0x11, 0x7c, 0xec, 0x9c, 0x35, 0x79, 0x17,
        0x65, 0xac, 0xbd, 0x87, 0x01, 0xad, 0x79, 0x84,
        0x5b, 0xf9, 0xfe, 0x3f, 0xba, 0x48, 0x7b, 0xc9,
        0x63, 0x21, 0x93, 0x06,
};

/********************************************************
     algorithm = AES-GCM-ESP
           key = 4c80cdefbb5d10da906ac73c3613a634
                 (16 octets)
           spi = 00004321
           seq = 8765432100000007
                 (8 octets)
         nonce = 22433c644855ec7d3a234bfd
     plaintext = 0800c6cd020007006162636465666768
                 696a6b6c6d6e6f707172737401020201
                 (32 octets)
           aad = 000043218765432100000007
                 (12 octets)
     ctext+tag = 74752e8aeb5d873cd7c0f4acc36c4bff
                 84b7d7b98f0ca8b6acda6894bc619069
                 ef9cbc28fe1b56a7c4e0d58c86cd2bc0
                 (48 octets)
        packet = 00004321000000074855ec7d3a234bfd
                 74752e8aeb5d873cd7c0f4acc36c4bff
                 84b7d7b98f0ca8b6acda6894bc619069
                 ef9cbc28fe1b56a7c4e0d58c86cd2bc0
                 (64 octets)
*******************************************************/
static const uint8_t xxx_17_key[] = {
        0x4c, 0x80, 0xcd, 0xef, 0xbb, 0x5d, 0x10, 0xda,
        0x90, 0x6a, 0xc7, 0x3c, 0x36, 0x13, 0xa6, 0x34,
};
static const uint8_t xxx_17_nonce[] = {
        0x22, 0x43, 0x3c, 0x64, 0x48, 0x55, 0xec, 0x7d,
        0x3a, 0x23, 0x4b, 0xfd,
};
static const uint8_t xxx_17_aad[] = {
        0x00, 0x00, 0x43, 0x21, 0x87, 0x65, 0x43, 0x21,
        0x00, 0x00, 0x00, 0x07,
};
static const uint8_t xxx_17_plaintext[] = {
        0x08, 0x00, 0xc6, 0xcd, 0x02, 0x00, 0x07, 0x00,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x01, 0x02, 0x02, 0x01,
};
static const uint8_t xxx_17_icv[] = {
        0xef, 0x9c, 0xbc, 0x28, 0xfe, 0x1b, 0x56, 0xa7,
        0xc4, 0xe0, 0xd5, 0x8c, 0x86, 0xcd, 0x2b, 0xc0,
};
static const uint8_t xxx_17_ciphertext[] = {
        0x74, 0x75, 0x2e, 0x8a, 0xeb, 0x5d, 0x87, 0x3c,
        0xd7, 0xc0, 0xf4, 0xac, 0xc3, 0x6c, 0x4b, 0xff,
        0x84, 0xb7, 0xd7, 0xb9, 0x8f, 0x0c, 0xa8, 0xb6,
        0xac, 0xda, 0x68, 0x94, 0xbc, 0x61, 0x90, 0x69,
};

/*********************************************************/

struct gcm_params {
        const uint8_t *key;
        size_t key_len;
        const uint8_t *nonce;
        size_t nonce_len;
        const uint8_t *aad;
        size_t aad_len;
        const uint8_t *plaintext;
        size_t plaintext_len;
        const uint8_t *ciphertext;
        const uint8_t *icv;
        size_t icv_len;
};

#define GCM_PARMS_SET(name)                                 \
        {                                                   \
                .key           = name##_key,                \
                .key_len       = sizeof(name##_key),        \
                .nonce         = name##_nonce,              \
                .nonce_len     = sizeof(name##_nonce),      \
                .aad           = name##_aad,                \
                .aad_len       = sizeof(name##_aad),        \
                .plaintext     = name##_plaintext,          \
                .plaintext_len = sizeof(name##_plaintext),  \
                .ciphertext    = name##_ciphertext,         \
                .icv           = name##_icv,                \
                .icv_len       = sizeof(name##_icv),        \
    }

static const struct gcm_params GCM_PARAMS[] = {
        GCM_PARMS_SET(xxx_1),
        GCM_PARMS_SET(xxx_2),
        GCM_PARMS_SET(xxx_3),
        GCM_PARMS_SET(xxx_4),
        GCM_PARMS_SET(xxx_5),
        GCM_PARMS_SET(xxx_6),
        GCM_PARMS_SET(xxx_7),
        GCM_PARMS_SET(xxx_8),
        GCM_PARMS_SET(xxx_9),
        GCM_PARMS_SET(xxx_10),
        GCM_PARMS_SET(xxx_11),
        GCM_PARMS_SET(xxx_12),
        GCM_PARMS_SET(xxx_13),
        GCM_PARMS_SET(xxx_14),
        GCM_PARMS_SET(xxx_15),
        GCM_PARMS_SET(xxx_16),
        GCM_PARMS_SET(xxx_17),
};

static const uint8_t IV_NED_MARK[] = { 0,0,0,1 };

#include <openssl/aes.h>

static enum result_e
gcm_key_expand(const struct handler_s *handler,
               size_t key_len,
               const void *key,
               struct gcm_data *gdata)
{
        switch (key_len) {
        case 16:
                handler->keyexp_enc_128(key, gdata->expanded_keys);
                handler->gcm_precomp_128(gdata, NULL);
                break;
        case 24:
                handler->keyexp_enc_192(key, gdata->expanded_keys);
                handler->gcm_precomp_192(gdata, NULL);
                break;
        case 32:
                handler->keyexp_enc_256(key, gdata->expanded_keys);
                handler->gcm_precomp_256(gdata, NULL);
                break;

        default:
                return FAIL;
        }
        return OK;
}

static enum result_e
gcm_enc(const struct handler_s *handler,
        size_t key_len,
        struct gcm_data *gdata,
        void *out,
        const void *in,
        size_t in_len,
        void *iv,
        const void *aad,
        size_t aad_len,
        void *auth_tag,
        size_t auth_tag_len)
{
        enum result_e ret = FAIL;

        switch (key_len) {
        case 16:
                handler->gcm_enc_128(gdata, out, in, in_len, iv,
                                     aad, aad_len, auth_tag, auth_tag_len);
                        ret = OK;
                break;
        case 24:
                handler->gcm_enc_192(gdata, out, in, in_len, iv,
                                     aad, aad_len, auth_tag, auth_tag_len);
                        ret = OK;
                break;
        case 32:
               handler->gcm_enc_256(gdata, out, in, in_len, iv,
                                    aad, aad_len, auth_tag, auth_tag_len);
                        ret = OK;
        default:
                break;
        }
        return ret;
}

static enum result_e
gcm_dec(const struct handler_s *handler,
        size_t key_len,
        struct gcm_data *gdata,
        void *out,
        const void *in,
        size_t in_len,
        void *iv,
        const void *aad,
        size_t aad_len,
        void *auth_tag,
        size_t auth_tag_len)
{
        enum result_e ret = FAIL;

        switch (key_len) {
        case 16:
                handler->gcm_dec_128(gdata, out, in, in_len, iv,
                                     aad, aad_len, auth_tag, auth_tag_len);
                        ret = OK;
                break;
        case 24:
                handler->gcm_dec_192(gdata, out, in, in_len, iv,
                                     aad, aad_len, auth_tag, auth_tag_len);
                        ret = OK;
                break;
        case 32:
               handler->gcm_dec_256(gdata, out, in, in_len, iv,
                                    aad, aad_len, auth_tag, auth_tag_len);
                        ret = OK;
        default:
                break;
        }
        return ret;
}

/*
 *
 */
int
gcm_test(enum capability_e cap)
{
        struct gcm_data gdata __attribute__((aligned(16)));
        uint8_t iv[16] __attribute__((aligned(16)));
        uint8_t aad[16];
        uint8_t tag[16];
        uint8_t packet[96];
        int results[NB_RESULTS];
        unsigned i;
        enum result_e ret;
        const struct handler_s *handler = get_handler(cap);

        FPRINTF(stderr, "Testing AES GCM\n");

        memset(results, 0, sizeof(results));

        for (i = 0; i < ARRAYOF(GCM_PARAMS); i++) {

                memset(iv, 0, sizeof(iv));
                memset(aad, 0, sizeof(aad));
                memset(tag, 0, sizeof(tag));
                memset(&gdata, 0, sizeof(gdata));

                FPRINTF(stderr,
                        "%uth key:%zu nonce:%zu aad:%zu txt:%zu icv:%zu ...",
                        i + 1,
                        GCM_PARAMS[i].key_len,
                        GCM_PARAMS[i].nonce_len,
                        GCM_PARAMS[i].aad_len,
                        GCM_PARAMS[i].plaintext_len,
                        GCM_PARAMS[i].icv_len);

                if (GCM_PARAMS[i].plaintext_len == 0) {
                        FPRINTF(stderr, "not supported\n");
                        results[SKIP]++;
                        continue;
                }

                if (sizeof(packet) <  GCM_PARAMS[i].plaintext_len) {
                        FPRINTF(stderr, "invalid params, too long text\n");
                        results[FAIL]++;
                        continue;
                }

                ret = gcm_key_expand(handler, GCM_PARAMS[i].key_len,
                                     GCM_PARAMS[i].key, &gdata);
                results[ret]++;
                switch (ret) {
                case OK:
                        break;
                case FAIL:
                        FPRINTF(stderr, "failed key expand\n");
                        continue;
                case SKIP:
                        FPRINTF(stderr, "not supported key length\n");
                        continue;
                default:
                        break;
                }

                memcpy(iv, GCM_PARAMS[i].nonce, GCM_PARAMS[i].nonce_len);
                memcpy(&iv[GCM_PARAMS[i].nonce_len], IV_NED_MARK,
                       sizeof(IV_NED_MARK));
                memcpy(aad, GCM_PARAMS[i].aad, GCM_PARAMS[i].aad_len);

                ret = gcm_enc(handler, GCM_PARAMS[i].key_len,
                              &gdata, packet,
                              GCM_PARAMS[i].plaintext,
                              GCM_PARAMS[i].plaintext_len,
                              iv,
                              aad, GCM_PARAMS[i].aad_len,
                              tag, GCM_PARAMS[i].icv_len);
                results[ret]++;
                switch (ret) {
                case FAIL:
                        FPRINTF(stderr, "failed encryption\n");
                        break;
                case OK:
                        if (memcmp(packet, GCM_PARAMS[i].ciphertext,
                                   GCM_PARAMS[i].plaintext_len)) {
                                results[FAIL]++;
                                FPRINTF(stderr, "mismatched ciphertext ... ");
                        } else if (memcmp(tag, GCM_PARAMS[i].icv,
                                          GCM_PARAMS[i].icv_len)) {
                                results[FAIL]++;
                                FPRINTF(stderr, "mismatched enc icv ...  ");
                        } else {
                                results[OK]++;
                        }
                        memset(tag, 0, sizeof(tag));
                        break;
                case SKIP:
                default:
                        break;
                }

                ret = gcm_dec(handler, GCM_PARAMS[i].key_len,
                              &gdata, packet,
                              GCM_PARAMS[i].ciphertext,
                              GCM_PARAMS[i].plaintext_len,
                              iv,
                              aad, GCM_PARAMS[i].aad_len,
                              tag, GCM_PARAMS[i].icv_len);
                results[ret]++;
                switch (ret) {
                case FAIL:
                        FPRINTF(stderr, "failed decryption\n");
                        break;
                case OK:
                        if (memcmp(packet, GCM_PARAMS[i].plaintext,
                                   GCM_PARAMS[i].plaintext_len)) {
                                results[FAIL]++;
                                FPRINTF(stderr, "mismatched plaintext\n");
                        } else if (memcmp(tag, GCM_PARAMS[i].icv,
                                          GCM_PARAMS[i].icv_len)) {
                                results[FAIL]++;
                                FPRINTF(stderr, "mismatched dec icv\n");
                        } else {
                                results[OK]++;
                                FPRINTF(stderr, "Ok\n");
                        }
                        break;
                case SKIP:
                default:
                        break;
                }
        }

        FPRINTF(stderr, "Ok:%d Fail:%d Skip:%d\n",
                results[OK], results[FAIL], results[SKIP]);
        return results[FAIL] ? -1 : 0;
}

#if 0
static int
key_gen_test(void)
{
        struct gcm_data gdata __attribute__((aligned(16)));
        uint8_t enc_key[16*15] __attribute__((aligned(16)));
        uint8_t dec_key[16*15] __attribute__((aligned(16)));
        uint8_t key[32] = { 0 };

        /* SSE */
        memset(enc_key, 0x55, sizeof(enc_key));
        memset(gdata.expanded_keys, 0xaa, sizeof(gdata.expanded_keys));
        aes_keyexp_128_sse(key, enc_key, dec_key);
        aes_keyexp_128_enc_sse(key, gdata.expanded_keys);
        if (memcmp(enc_key, gdata.expanded_keys, 16*11)) {
                fprintf(stderr, "SSE 128 failed enc key expand\n");
                return -1;
        }
        memset(enc_key, 0x55, sizeof(enc_key));
        memset(gdata.expanded_keys, 0xaa, sizeof(gdata.expanded_keys));
        aes_keyexp_192_sse(key, enc_key, dec_key);
        aes_keyexp_192_enc_sse(key, gdata.expanded_keys);
        if (memcmp(enc_key, gdata.expanded_keys, 16*13)) {
                fprintf(stderr, "SSE 192 failed enc key expand\n");
                return -1;
        }
        memset(enc_key, 0x55, sizeof(enc_key));
        memset(gdata.expanded_keys, 0xaa, sizeof(gdata.expanded_keys));
        aes_keyexp_256_sse(key, enc_key, dec_key);
        aes_keyexp_256_enc_sse(key, gdata.expanded_keys);
        if (memcmp(enc_key, gdata.expanded_keys, 16*15)) {
                fprintf(stderr, "SSE 256 failed enc key expand\n");
                return -1;
        }

        /* AVX */
        memset(enc_key, 0x55, sizeof(enc_key));
        memset(gdata.expanded_keys, 0xaa, sizeof(gdata.expanded_keys));
        aes_keyexp_128_avx(key, enc_key, dec_key);
        aes_keyexp_128_enc_avx(key, gdata.expanded_keys);
        if (memcmp(enc_key, gdata.expanded_keys, 16*11)) {
                fprintf(stderr, "AVX 128 failed enc key expand\n");
                return -1;
        }
        memset(enc_key, 0x55, sizeof(enc_key));
        memset(gdata.expanded_keys, 0xaa, sizeof(gdata.expanded_keys));
        aes_keyexp_192_avx(key, enc_key, dec_key);
        aes_keyexp_192_enc_avx(key, gdata.expanded_keys);
        if (memcmp(enc_key, gdata.expanded_keys, 16*13)) {
                fprintf(stderr, "AVX 192 failed enc key expand\n");
                return -1;
        }
        memset(enc_key, 0x55, sizeof(enc_key));
        memset(gdata.expanded_keys, 0xaa, sizeof(gdata.expanded_keys));
        aes_keyexp_256_avx(key, enc_key, dec_key);
        aes_keyexp_256_enc_avx(key, gdata.expanded_keys);
        if (memcmp(enc_key, gdata.expanded_keys, 16*15)) {
                fprintf(stderr, "AVX 256 failed enc key expand\n");
                return -1;
        }

        return 0;
}
#endif

